#!/usr/bin/env node

/**
 * badge-gen - Generate README badge markdown for npm packages
 * Usage: badge-gen <package-name> [--output file.md]
 * 
 * Built during Nightly Build - 2026-01-30
 */

const https = require('https');
const fs = require('fs');
const path = require('path');

const HELP = `
badge-gen - Generate README badges for npm packages

Usage:
  badge-gen <package-name> [options]

Options:
  --output, -o <file>   Append badges to file instead of stdout
  --help, -h            Show this help message

Examples:
  badge-gen ai-pdf-builder
  badge-gen web-qa-bot --output README.md
`;

function parseArgs(args) {
  const result = { packageName: null, output: null };
  
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg === '--help' || arg === '-h') {
      console.log(HELP);
      process.exit(0);
    } else if (arg === '--output' || arg === '-o') {
      result.output = args[++i];
    } else if (!arg.startsWith('-')) {
      result.packageName = arg;
    }
  }
  
  return result;
}

function fetchJson(url) {
  return new Promise((resolve, reject) => {
    https.get(url, { headers: { 'User-Agent': 'badge-gen/1.0' } }, (res) => {
      let data = '';
      res.on('data', chunk => data += chunk);
      res.on('end', () => {
        if (res.statusCode === 404) {
          reject(new Error('Package not found on npm'));
        } else if (res.statusCode !== 200) {
          reject(new Error(`HTTP ${res.statusCode}`));
        } else {
          try {
            resolve(JSON.parse(data));
          } catch (e) {
            reject(new Error('Invalid JSON response'));
          }
        }
      });
    }).on('error', reject);
  });
}

function generateBadges(pkg) {
  const name = pkg.name;
  const encodedName = encodeURIComponent(name);
  const version = pkg['dist-tags']?.latest || 'unknown';
  const license = pkg.license || 'unknown';
  const engines = pkg.versions?.[version]?.engines?.node || '>=14';
  
  const badges = [];
  
  // npm version badge
  badges.push(`[![npm version](https://img.shields.io/npm/v/${encodedName}.svg?style=flat-square)](https://www.npmjs.com/package/${encodedName})`);
  
  // npm downloads badge
  badges.push(`[![npm downloads](https://img.shields.io/npm/dm/${encodedName}.svg?style=flat-square)](https://www.npmjs.com/package/${encodedName})`);
  
  // license badge
  badges.push(`[![license](https://img.shields.io/npm/l/${encodedName}.svg?style=flat-square)](https://www.npmjs.com/package/${encodedName})`);
  
  // node version badge
  const nodeVersion = engines.replace(/[>=<^~]/g, '');
  badges.push(`[![node](https://img.shields.io/badge/node-${encodeURIComponent('>=' + nodeVersion)}-brightgreen.svg?style=flat-square)]()`);
  
  return badges;
}

async function main() {
  const args = parseArgs(process.argv.slice(2));
  
  if (!args.packageName) {
    console.error('Error: Package name required\n');
    console.log(HELP);
    process.exit(1);
  }
  
  try {
    console.log(`Fetching ${args.packageName} from npm...`);
    
    const pkg = await fetchJson(`https://registry.npmjs.org/${encodeURIComponent(args.packageName)}`);
    const badges = generateBadges(pkg);
    
    const output = `\n<!-- Badges generated by badge-gen -->\n${badges.join(' ')}\n`;
    
    if (args.output) {
      const filePath = path.resolve(args.output);
      fs.appendFileSync(filePath, output);
      console.log(`✅ Badges appended to ${filePath}`);
    } else {
      console.log('\n--- Copy below ---\n');
      console.log(badges.join(' '));
      console.log('\n--- End ---\n');
    }
    
    // Show preview
    console.log('Package info:');
    console.log(`  Name: ${pkg.name}`);
    console.log(`  Version: ${pkg['dist-tags']?.latest}`);
    console.log(`  License: ${pkg.license || 'not specified'}`);
    console.log(`  Description: ${pkg.description || 'none'}`);
    
  } catch (err) {
    console.error(`❌ Error: ${err.message}`);
    process.exit(1);
  }
}

main();
